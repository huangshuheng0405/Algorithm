# 错位排列

**derangement**

错位排列是没有任何元素出现在其有序位置的排列。即，对于$1~n$的排列$P$，如果满足$P_i\neq i$,则称$P$是$n$的错位排列

将n个不同的信编号分别为1、2、3、4、5，现在把这五封信放在编号为1、2、3、4、5的信封中，要求信封的编号与信的编号不一样，问有多少种不同的放置方法？

假设考虑第n个信封，初始化暂时把第n封信放在第n个信封中，然后考虑两种情况的递推：

​	1.前面n-1个信封全部装错

​	2.前面n-1个信封有一个没装错其余都装错

对于第一种情况，前面n个信封全部装错，所以第n个信只要和前面任意一个交换位置即可，总共可有$D_{n-1}\times (n-1)$种情况

对于第二种情况，前面n-1个信封有一个没有装错（有n-1种）其余全部装错，把没装错的和当前这个信交换即可得到全错排列情况$D_{n-2}\times(n-1)$

其他情况不可能通过一次操作把他变成一个长度为n的错排列

得到递推式$D_n=(n-1)\times(D_{n-1}+D_{n-2})$

另一个递推关系$D_n=nD_{n-1}+(-1)^n$
# 信封问题

## 题目描述

某人写了 $n$ 封信和 $n$ 个信封，如果所有的信都装错了信封。求所有信都装错信封共有多少种不同情况。

## 输入格式

一个信封数 $n$，保证 $n \le 20$。

## 输出格式

一个整数，代表有多少种情况。

## 样例 #1

### 样例输入 #1

```
2
```

### 样例输出 #1

```
1
```

## 样例 #2

### 样例输入 #2

```
3
```

### 样例输出 #2

```
2
```

## 提示

对于 $100 \%$ 的数据，$1 \le n \le 20$。

# 题解

```c++
#include <bits/stdc++.h>

using i64 = long long;

void solve() {
    int n;
    std::cin >> n;

    std::vector<i64> d(n + 1);
    d[1] = 0;
    d[2] = 1;
    for (int i = 3; i <= n; i++) {
        d[i] = (i - 1) * (d[i - 1] + d[i - 2]);
    }

    std::cout << d[n] << "\n";
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int t = 1;

    // std::cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

