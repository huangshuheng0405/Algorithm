# 汉诺塔

有$A$，$B$，$C$三根柱子，开始时$A$柱子有$n$个圆盘，圆盘大的必须放在下面，每次只能移动一个圆盘，求把所有圆盘移到$C$处的最少步数

1. 当只有一个圆盘时，直接将圆盘移到$C$处，此时$f(x) = 1$
2. 我们考虑 $n=k$ 是已经得到 $f(k)$，则当 $n=k+1$ 时，我们要让大盘移到 $C$ 处，必须先用$f(k)$ 步把 $k$个小盘移到$B$处（这样才能让大盘的移动没有多余步骤），然后还要再用$f(n)$ 步将$k$个小盘移到$C$ 处，得到$f(k+1)=f(k)\times2 +1$。
3. $f(k+1)+1=2\times(f(k)+1)$可以得到$\{f(n)+1\}$为公比为$2$的等比数列
4. 最后求得公式为$f(n)=2^n-1$

# P1760 通天之汉诺塔

## 题目背景

直达通天路·小A历险记第四篇

## 题目描述

在你的帮助下，小 A 成功收集到了宝贵的数据，他终于来到了传说中连接通天路的通天山。但是这距离通天路仍然有一段距离，但是小 A 突然发现他没有地图！！！但是幸运的是，他在山脚下发现了一个宝箱。根据经验判断（小 A 有经验吗？），地图应该就在其中！

在宝箱上，有三根柱子以及在一根柱子上的 $n$ 个圆盘。小 A 在经过很长时间判断后，觉得这就是 hanoi 塔！（这都要琢磨）。但是移动是需要时间的，所以小 A 必须要通过制造延寿药水来完成这项任务。现在，他请你告诉他需要多少步完成，以便他造足够的延寿药水。

## 输入格式

一个数 $n$，表示有 $n$ 个圆盘。

## 输出格式

一个数 $s$，表示需要 $s$ 步。

## 输入输出样例 #1

### 输入 #1

```
31
```

### 输出 #1

```
2147483647
```

## 输入输出样例 #2

### 输入 #2

```
15
```

### 输出 #2

```
32767
```

## 说明/提示

### 数据范围及约定

对于所有数据，$n \le 15000$。

# solve

高精度

```c++
#include <bits/stdc++.h>

using i64 = long long;

int a[10000];

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;

    a[1] = 1;
    int len = 1;

    auto multiply = [&]() {
        for (int i = 1; i <= len; i++) {
            a[i] *= 2;
        }

        for (int i = 1; i <= len; i++) {
            if (a[i] > 9) {
                a[i + 1]++;
                a[i] -= 10;
            }
        }

        if (a[len + 1] > 0) {
            len++;
        }
    };

    for (int i = 0; i < n; i++) {
        multiply();
    }

    for (int i = len; i > 1; i--) {
        std::cout << a[i];
    }

    std::cout << a[1] - 1 << "\n";// 最后一位不会出现0 直接减1

    return 0;
}
```

汉诺塔问题，写出具体的移动步骤

- 只有一个盘子时，直接从源柱移动到目标柱
- 步骤 $1$：将前 $n-1$ 个盘子从源柱移动到辅助柱
- 步骤 $2$：将第 $n$ 个盘子（最大的）从源柱移动到目标柱
- 步骤 $3$：将那$n-1$个盘子从辅助柱移动到目标柱

```c++
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);

    int n;
    std::cin >> n;

    auto hanoi = [&](auto &&self, int n, int a, int b, int c) ->void {
        if (n == 1) {
            std::cout << a << " " << c << "\n";
        } else {
            self(self, n - 1, a, c, b);          //   将前 n-1 个盘子从源柱移动到辅助柱

            std::cout << a << " " << c << "\n";  //   将第 n 个盘子（最大的）从源柱移动到目标柱
            
            self(self, n - 1, b, a, c);          //   将那 n-1 个盘子从辅助柱移动到目标柱
        }
    };
    std::cout << std::pow(2, n) - 1 << "\n";
    hanoi(hanoi, n, 1, 2, 3);

    return 0;
}
```

