 IR101给樊神出了一道题，一个长度为*n*的序列，每一个位置可以填为1或者填为0，但连续的1的长度不能超过2，连续的0的长度不超过3，问有多少种方案符合条件？由于答案过大，因此答案对1*e*9+7取模。
樊神的智慧有限，觉得太难了，因此求助你帮他解决这个问题。 

输入一个数字$n$

输出一个数字表示模$1e9+7$的方案数

# 题解

计数dp

[西南民大校赛]: http://162.14.124.219/problem/C-11-E

```c++
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;

i64 dp[1000000 + 1][3][4]; // i表示当前处理序列的第i个位置
                           // j表示第i个位置结尾连续1的数量（可以是0、1、2）
                           // k表示第i个位置结尾连续0的数量（可以时0、1、2、3）
const int mod = 1e9 + 7;

int main() {
    int n;
    cin >> n;
    dp[0][0][0] = 1;
    for (int i = 1; i <= n; i++) {
        // 当前位置填1
        for (int j = 0; j <= 3;
             j++) { // 累加前一位不是1的情况 前面的零可以是0到3
            dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][j]) % mod;
        }
        dp[i][2][0] = dp[i - 1][1][0]; // 累加前一位是1的情况

        // 当前位置填0
        for (int j = 0; j <= 2; j++) { // 前一位不是0的情况 前面1的数量是0到2
            dp[i][0][1] = (dp[i][0][1] + dp[i - 1][j][0]) % mod;
        }
        dp[i][0][2] = dp[i - 1][0][1]; // 前面是一个0
        dp[i][0][3] = dp[i - 1][0][2]; // 前面是两个0
    }

    i64 ans = 0;
    for (int i = 0; i <= 2; i++) {
        for (int j = 0; j <= 3; j++) {
            ans = (ans + dp[n][i][j]) % mod;
        }
    }

    cout << ans << '\n';
}
```

