# 差分

给定一个序列$a$，它的差分序列$b$定义为：
$$
\large b[1]=a[1],b[i]=a[i]-a[i-1],(2\leq i\leq n)
$$

$a$数组就是对$b$数组求前缀和

### 证明

$a[i]=b[i]+a[i-1]$

$a[1]=b[1]$

$a[2]=b[2]+a[1]=b[2]+b[1]$

$a[3]=b[3]+a[2]=b[3]+b[2]+b[1]$

### 性质

$a_i$的值是$b_i$的前缀和，即$a_n=\sum^n_{i=1}b_i$

把序列$a$的区间$[l,r]$加上$k$等价于其差分序列$b$的点$b[l]$加$k$，点$b[r+1]$减去$k$，其他位置不变，把区间操作转换为**两点操作**，最后对差分数组进行前缀和就可以还原数组。

修改操作复杂度从$O(n)$降到$O(1)$

# 语文成绩

## 题目背景

语文考试结束了，成绩还是一如既往地有问题。

## 题目描述

语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？

## 输入格式

第一行有两个整数 $n$，$p$，代表学生数与增加分数的次数。

第二行有 $n$ 个数，$a_1 \sim a_n$，代表各个学生的初始成绩。

接下来 $p$ 行，每行有三个数，$x$，$y$，$z$，代表给第 $x$ 个到第 $y$ 个学生每人增加 $z$ 分。

## 输出格式

输出仅一行，代表更改分数后，全班的最低分。

## 样例 #1

### 样例输入 #1

```
3 2
1 1 1
1 2 1
2 3 1
```

### 样例输出 #1

```
2
```

## 提示

对于 $40\%$ 的数据，有 $n \le 10^3$。

对于 $60\%$ 的数据，有 $n \le 10^4$。

对于 $80\%$ 的数据，有 $n \le 10^5$。

对于 $100\%$ 的数据，有 $n \le 5\times 10^6$，$p \le n$，学生初始成绩 $ \le 100$，$z \le 100$。

### 题解

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 5e6 + 5;
int a[N], b[N], n, p, x, y, k;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> p;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        b[i] = a[i] - a[i - 1]; // 差分数组
    }

    int ans = 1e9;
    while (p--) {
        cin >> x >> y >> k;
        b[x] += k; // 差分将区间操作转化为两点操作
        b[y + 1] -= k;
    }
    for (int i = 1; i <= n; i++) {
        a[i] = a[i - 1] + b[i]; // 利用前缀和还原数组
        ans = min(ans, a[i]);
    }
    cout << ans << endl;
    return 0;
}
```

# 二维差分

对于原序列$a$，它的差分序列$diff$为
$$
\large diff[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1];
$$
修改操作：对矩阵$x1,y1$到$x2,y2$中全部元素加$k$
$$
diff[x1][y1]+=k \\ diff[x1][y2+1]-=k\\ diff[x2+1][y1]-=k\\ diff[x2+1][y2+1]+=k
$$
$diff[x2+1][y2+1]$多减一次要加上

还原数组利用前缀和

# 地毯

## 题目描述

在 $n\times n$ 的格子上有 $m$ 个地毯。

给出这些地毯的信息，问每个点被多少个地毯覆盖。

## 输入格式

第一行，两个正整数 $n,m$。意义如题所述。

接下来 $m$ 行，每行两个坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，代表一块地毯，左上角是 $(x_1,y_1)$，右下角是 $(x_2,y_2)$。

## 输出格式

输出 $n$ 行，每行 $n$ 个正整数。

第 $i$ 行第 $j$ 列的正整数表示 $(i,j)$ 这个格子被多少个地毯覆盖。

## 样例 #1

### 样例输入 #1

```
5 3
2 2 3 3
3 3 5 5
1 2 1 4
```

### 样例输出 #1

```
0 1 1 1 0
0 1 1 0 0
0 1 2 1 1
0 0 1 1 1
0 0 1 1 1
```

## 提示

### 样例解释

覆盖第一个地毯后：

| $0$  | $0$  | $0$  | $0$  | $0$  |
| :--: | :--: | :--: | :--: | :--: |
| $0$  | $1$  | $1$  | $0$  | $0$  |
| $0$  | $1$  | $1$  | $0$  | $0$  |
| $0$  | $0$  | $0$  | $0$  | $0$  |
| $0$  | $0$  | $0$  | $0$  | $0$  |

覆盖第一、二个地毯后：

| $0$  | $0$  | $0$  | $0$  | $0$  |
| :--: | :--: | :--: | :--: | :--: |
| $0$  | $1$  | $1$  | $0$  | $0$  |
| $0$  | $1$  | $2$  | $1$  | $1$  |
| $0$  | $0$  | $1$  | $1$  | $1$  |
| $0$  | $0$  | $1$  | $1$  | $1$  |

覆盖所有地毯后：

| $0$  | $1$  | $1$  | $1$  | $0$  |
| :--: | :--: | :--: | :--: | :--: |
| $0$  | $1$  | $1$  | $0$  | $0$  |
| $0$  | $1$  | $2$  | $1$  | $1$  |
| $0$  | $0$  | $1$  | $1$  | $1$  |
| $0$  | $0$  | $1$  | $1$  | $1$  |

---

### 数据范围

对于 $20\%$ 的数据，有 $n\le 50$，$m\le 100$。

对于 $100\%$ 的数据，有 $n,m\le 1000$。

### 题解

```c++
#include <iostream>
#include <vector>
using namespace std;

using i64 = long long;

void solve() {
    int n, m, q;
    cin >> n >> m >> q;

    vector<vector<i64>> a(n + 2, vector<i64>(m + 2));
    vector<vector<i64>> diff(n + 2, vector<i64>(m + 2));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
        }
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            diff[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1];
        }
    }

    while (q--) {
        int x1, x2, y1, y2, k;
        cin >> x1 >> y1 >> x2 >> y2 >> k;

        diff[x1][y1] += k;
        diff[x1][y2 + 1] -= k;
        diff[x2 + 1][y1] -= k;
        diff[x2 + 1][y2 + 1] += k;
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            diff[i][j] += diff[i][j - 1] + diff[i - 1][j] - diff[i - 1][j - 1];
            cout << diff[i][j] << " ";
        }
        cout << "\n";
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int _ = 1;

    // cin >> _;
    while (_--) {
        solve();
    }
    return 0;
}
```

